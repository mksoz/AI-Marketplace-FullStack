generator client {
  provider = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  extensions = [pgvector(map: "vector")] // Requires preview feature
}

enum UserRole {
  CLIENT
  VENDOR
  ADMIN
}

enum ProjectStatus {
  OPEN
  PROPOSED        // New: Client proposed to Vendor
  CONTACTED       // New: Vendor acknowledged/contacted
  IN_NEGOTIATION  // New: Vendor replied/countered
  ACCEPTED        // New: Vendor accepted (Ready to start)
  DECLINED        // New: Vendor declined
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

// Basic User model for auth
model User {
  id            String    @id @default(uuid())
  email         String    @unique
  password      String
  role          UserRole  @default(CLIENT)
  simulationMode Boolean  @default(true)  // Simulation mode for testing payments
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  clientProfile ClientProfile?
  vendorProfile VendorProfile?
  
  conversations Conversation[]
  messages      Message[]
  notifications Notification[]
  
  reportedIncidents Incident[] @relation("Reporter")
  paymentMethods    PaymentMethod[]
}

model ClientProfile {
  id          String   @id @default(uuid())
  userId      String   @unique
  user        User     @relation(fields: [userId], references: [id])
  companyName String?
  industry    String?
  website     String?
  
  projects      Project[]
  savedVendors  SavedVendor[]
  account       ClientAccount?
}

enum MilestoneStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  PAID
}

model VendorProfile {
  id          String   @id @default(uuid())
  userId      String   @unique
  user        User     @relation(fields: [userId], references: [id])
  companyName String?
  bio         String?
  hourlyRate  Float?
  skills      String[] 
  
  proposals       Proposal[]
  reviews         Review[]
  templates       RequirementTemplate[] @relation("VendorTemplates")
  
  // Projects where this vendor is directly assigned/requested
  projects        Project[] @relation("VendorProjects")
  savedByClients  SavedVendor[]
  account         VendorAccount?
}

model RequirementTemplate {
  id              String        @id @default(uuid())
  vendorId        String
  vendor          VendorProfile @relation("VendorTemplates", fields: [vendorId], references: [id])
  name            String
  description     String?
  structure       Json          
  isDefault       Boolean       @default(false)
  status          String        @default("DRAFT") // DRAFT, PUBLISHED
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
}

model Project {
  id          String        @id @default(uuid())
  clientId    String
  client      ClientProfile @relation(fields: [clientId], references: [id])
  
  // Optional: If the project is a direct request to a specific vendor
  vendorId    String?
  vendor      VendorProfile? @relation("VendorProjects", fields: [vendorId], references: [id])

  title       String
  description String
  budget      Float
  status      ProjectStatus @default(OPEN)
  
  // Stores the filled data from the RequirementTemplate
  templateData Json?        
  
  // Reason for rejection if status is DECLINED
  rejectionReason String?
  
  // Tracking & Management
  startDate   DateTime?
  endDate     DateTime?
  repoUrl     String?
  repoName    String?

  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  milestones  Milestone[]
  proposals   Proposal[]
  files       ProjectFile[]
  folders     ProjectFolder[]
  
  conversation Conversation?
  contract     Contract?
  
  // New Relations
  incidents   Incident[]
  reviews     Review[]
}

model ProjectFolder {
  id        String   @id @default(uuid())
  name      String
  projectId String
  project   Project  @relation(fields: [projectId], references: [id])
  parent    ProjectFolder? @relation("FolderHierarchy", fields: [parentId], references: [id])
  parentId  String?
  children  ProjectFolder[] @relation("FolderHierarchy")
  files     ProjectFile[]
  createdAt DateTime @default(now())
}

model ProjectFile {
  id        String   @id @default(uuid())
  name      String
  url       String
  size      Int
  mimeType  String
  projectId String
  project   Project  @relation(fields: [projectId], references: [id])
  folderId  String?
  folder    ProjectFolder? @relation(fields: [folderId], references: [id])
  uploaderId String
  createdAt DateTime @default(now())
}


model Milestone {
  id        String          @id @default(uuid())
  projectId String
  project   Project         @relation(fields: [projectId], references: [id])
  title     String
  description String?
  amount    Float
  status    MilestoneStatus @default(PENDING)
  dueDate   DateTime?
  order     Int             @default(0)
  isPaid    Boolean         @default(false)
  
  // For milestones without payment
  completionNote  String?
  completedAt     DateTime?
  
  // Payment request relation
  paymentRequest  PaymentRequest?
}

model Proposal {
  id        String   @id @default(uuid())
  projectId String
  project   Project  @relation(fields: [projectId], references: [id])
  vendorId  String
  vendor    VendorProfile @relation(fields: [vendorId], references: [id])
  price     Float
  coverLetter String
  status    String   @default("PENDING") // PENDING, ACCEPTED, REJECTED
  createdAt DateTime @default(now())
}

model Review {
  id        String   @id @default(uuid())
  projectId String?  
  project   Project? @relation(fields: [projectId], references: [id])
  vendorId  String
  vendor    VendorProfile @relation(fields: [vendorId], references: [id])
  rating    Int
  comment   String?
  createdAt DateTime @default(now())
}

model Conversation {
  id        String    @id @default(uuid())
  projectId String    @unique // One conversation per project for now
  project   Project   @relation(fields: [projectId], references: [id])
  
  participants User[] // Many-to-many implicit relation or manual if needed. For now simple implicit is fine or we rely on project client/vendor.
  
  messages  Message[]

  archivedBy String[] @default([])
  deletedBy  String[] @default([])

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
}

model Message {
  id             String       @id @default(uuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id])
  
  senderId       String
  sender         User         @relation(fields: [senderId], references: [id])
  
  content        String
  isRead         Boolean      @default(false)
  createdAt      DateTime     @default(now())
}

enum ContractStatus {
  DRAFT
  PENDING_SIGNATURE
  SIGNED
  CANCELLED
}

model Contract {
  id              String         @id @default(uuid())
  projectId       String         @unique
  project         Project        @relation(fields: [projectId], references: [id])
  
  content         String         @db.Text
  status          String         @default("DRAFT") // DRAFT, PROPOSED, NEGOTIATING, SIGNED
  
  clientSigned    Boolean        @default(false)
  clientSignedAt  DateTime?
  vendorSigned    Boolean        @default(false)
  vendorSignedAt  DateTime?
  
  activeVersionId String?        @unique
  versions        ContractVersion[]
  
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
}

model ContractVersion {
  id            String    @id @default(uuid())
  contractId    String
  contract      Contract  @relation(fields: [contractId], references: [id], onDelete: Cascade)
  
  versionNumber Int
  content       String    @db.Text
  changeMessage String?   @db.Text
  
  createdBy     String    
  status        String    @default("PROPOSED") // DRAFT, PROPOSED, ACCEPTED, REJECTED
  
  clientSignedAt DateTime?
  vendorSignedAt DateTime?
  createdAt     DateTime  @default(now())
}

enum NotificationType {
  INFO
  SUCCESS
  WARNING
  ERROR
}

enum IncidentStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum IncidentPriority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

model Incident {
  id          String   @id @default(uuid())
  projectId   String
  project     Project  @relation(fields: [projectId], references: [id])
  
  reporterId  String
  reporter    User     @relation("Reporter", fields: [reporterId], references: [id])
  
  title       String
  description String
  status      IncidentStatus   @default(OPEN)
  priority    IncidentPriority @default(MEDIUM)
  
  resolution  String?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Notification {
  id          String           @id @default(uuid())
  userId      String           
  user        User             @relation(fields: [userId], references: [id])
  type        NotificationType @default(INFO)
  title       String
  message     String
  link        String?          
  isRead      Boolean          @default(false)
  createdAt   DateTime         @default(now())
}

// SavedVendor: Tracks which clients have saved/favorited which vendors
model SavedVendor {
  id        String   @id @default(uuid())
  clientId  String
  vendorId  String
  createdAt DateTime @default(now())
  
  client ClientProfile @relation(fields: [clientId], references: [id], onDelete: Cascade)
  vendor VendorProfile @relation(fields: [vendorId], references: [id], onDelete: Cascade)
  
  @@unique([clientId, vendorId])
}


// ========================================
// FINANCIAL MANAGEMENT SYSTEM
// ========================================

enum PaymentRequestStatus {
  PENDING
  APPROVED
  REJECTED
  COMPLETED
}

model PaymentRequest {
  id            String                @id @default(uuid())
  milestoneId   String                @unique
  milestone     Milestone             @relation(fields: [milestoneId], references: [id])
  
  vendorNote    String?
  amount        Float
  status        PaymentRequestStatus  @default(PENDING)
  
  requestedAt   DateTime              @default(now())
  reviewedAt    DateTime?
  rejectionReason String?
  
  // Link to transaction when approved
  transactionId   String?           @unique
  transaction     Transaction?      @relation(fields: [transactionId], references: [id])
}

model ClientAccount {
  id            String      @id @default(uuid())
  clientId      String      @unique
  client        ClientProfile @relation(fields: [clientId], references: [id])
  
  balance       Float       @default(0)
  currency      String      @default("USD")
  
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  
  transactionsFrom  Transaction[] @relation("FromTransactions")
}

model VendorAccount {
  id            String      @id @default(uuid())
  vendorId      String      @unique
  vendor        VendorProfile @relation(fields: [vendorId], references: [id])
  
  balance       Float       @default(0)
  currency      String      @default("USD")
  
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  
  transactionsTo    Transaction[] @relation("ToTransactions")
}

enum TransactionType {
  DEPOSIT
  WITHDRAWAL
  PAYMENT
  REFUND
  FEE
}

enum TransactionStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

model Transaction {
  id            String            @id @default(uuid())
  
  // Amount and type
  amount        Float
  type          TransactionType
  status        TransactionStatus @default(PENDING)
  description   String?
  
  // Related accounts
  fromAccountId String?
  fromAccount   ClientAccount?    @relation(fields: [fromAccountId], references: [id], name: "FromTransactions")
  
  toAccountId   String?
  toAccount     VendorAccount?    @relation(fields: [toAccountId], references: [id], name: "ToTransactions")
  
  //Related payment request (if applicable)
  paymentRequest  PaymentRequest?
  
  // Related project/milestone
  projectId     String?
  milestoneId   String?
  
  // Metadata
  metadata      Json?
  
  createdAt     DateTime          @default(now())
  completedAt   DateTime?
}

enum PaymentMethodType {
  BANK_ACCOUNT
  CREDIT_CARD
  PAYPAL
  APPLE_PAY
  GOOGLE_PAY
}

model PaymentMethod {
  id            String            @id @default(uuid())
  userId        String
  user          User              @relation(fields: [userId], references: [id])
  
  type          PaymentMethodType
  isDefault     Boolean           @default(false)
  
  // Encrypted/Tokenized data
  last4         String?           // Last 4 digits for display
  brand         String?           // Visa, Mastercard, etc.
  metadata      Json?             // Store encrypted tokens, account info
  
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
}
