generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [pgvector(map: "vector")] // Requires preview feature
}

enum UserRole {
  CLIENT
  VENDOR
  ADMIN
}

enum ProjectStatus {
  OPEN
  PROPOSED // New: Client proposed to Vendor
  CONTACTED // New: Vendor acknowledged/contacted
  IN_NEGOTIATION // New: Vendor replied/countered
  ACCEPTED // New: Vendor accepted (Ready to start)
  DECLINED // New: Vendor declined
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

// Basic User model for auth
model User {
  id             String   @id @default(uuid())
  email          String   @unique
  password       String
  role           UserRole @default(CLIENT)
  simulationMode Boolean  @default(true) // Simulation mode for testing payments

  // Preferences (Phase 1)
  language   String @default("es") // es, en
  timezone   String @default("Europe/Madrid")
  currency   String @default("USD")
  dateFormat String @default("DD/MM/YYYY")
  theme      String @default("auto") // auto, light, dark

  // Security (Phase 1)
  twoFactorEnabled Boolean   @default(false)
  twoFactorSecret  String?
  lastLoginAt      DateTime?
  lastLoginIp      String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  clientProfile ClientProfile?
  vendorProfile VendorProfile?

  conversations          Conversation[]
  messages               Message[]
  notifications          Notification[]
  notificationPreference NotificationPreference?

  reportedIncidents Incident[]      @relation("Reporter")
  paymentMethods    PaymentMethod[]
  sessions          Session[]
  auditLogs         AuditLog[]
  
  // Calendar Relations
  createdEvents     CalendarEvent[] @relation("EventCreator")
  attendingEvents   EventAttendee[]
  reminders         EventReminder[]
}

model ClientProfile {
  id     String @id @default(uuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id])

  // General Info (Phase 1)
  companyName String?
  logoUrl     String?
  description String? @db.Text
  industry    String?
  website     String?
  country     String?
  city        String?

  // Billing (Future Phase 2)
  billingAddress    String?
  taxId             String?
  legalName         String?
  monthlySpendLimit Decimal?

  projects     Project[]
  savedVendors SavedVendor[]
  account      ClientAccount?
  calendarEvents CalendarEvent[] @relation("ClientEvents")
}

enum MilestoneStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  PAID
}

enum EventType {
  MILESTONE
  MEETING
  DEADLINE
  CUSTOM
}

enum EventStatus {
  PENDING
  CONFIRMED
  CANCELLED
  COMPLETED
}

enum AttendeeStatus {
  NO_RESPONSE
  ACCEPTED
  DECLINED
  TENTATIVE
}

model VendorProfile {
  id     String @id @default(uuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id])

  // General Info
  companyName String?
  logoUrl     String?
  bio         String?  @db.Text
  hourlyRate  Float?
  skills      String[]

  // Professional Details
  industry          String?
  website           String?
  country           String?
  city              String?
  languages         String[] @default([])
  yearsOfExperience Int?

  // Portfolio & Social
  portfolioUrl String?
  linkedinUrl  String?
  githubUrl    String?

  // Billing (Future Phase 2)
  billingAddress String?
  taxId          String?
  legalName      String?

  // AI Agent Configuration (Future)
  aiAgentEnabled Boolean @default(false)
  aiAgentConfig  Json? // Flexible config for AI agent settings

  proposals Proposal[]
  reviews   Review[]
  templates RequirementTemplate[] @relation("VendorTemplates")

  // Projects where this vendor is directly assigned/requested
  projects       Project[]      @relation("VendorProjects")
  savedByClients SavedVendor[]
  account        VendorAccount?
  calendarEvents CalendarEvent[] @relation("VendorEvents")
}

model GitHubSync {
  id        String   @id @default(uuid())
  projectId String   @unique
  project   Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  
  // Repository Info
  repoUrl       String  // Full GitHub URL
  repoOwner     String  // e.g., "octocat"
  repoName      String  // e.g., "Hello-World"
  repoBranch    String  @default("main")
  
  // Sync Status
  lastSyncAt    DateTime?
  syncStatus    String   @default("ACTIVE") // ACTIVE, ERROR, DISCONNECTED
  syncError     String?
  
  // GitHub Metadata
  repoStars     Int      @default(0)
  repoForks     Int      @default(0)
  repoLanguage  String?
  repoOpenIssues Int     @default(0)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  commits GitHubCommit[]
}

model GitHubCommit {
  id          String   @id @default(uuid())
  syncId      String
  sync        GitHubSync @relation(fields: [syncId], references: [id], onDelete: Cascade)
  
  // Commit Data
  sha         String   @unique
  message     String   @db.Text
  author      String
  authorEmail String?
  authorAvatar String?
  committedAt DateTime
  
  // Diff Stats
  additions   Int      @default(0)
  deletions   Int      @default(0)
  changedFiles Int     @default(0)
  
  createdAt   DateTime @default(now())
  
  @@index([syncId, committedAt(sort: Desc)])
}

model CalendarEvent {
  id          String      @id @default(uuid())
  
  // Basic Info
  title       String
  description String?     @db.Text
  type        EventType
  status      EventStatus @default(PENDING)
  
  // Timing
  startDate   DateTime
  endDate     DateTime
  isAllDay    Boolean     @default(false)
  timezone    String      @default("Europe/Madrid")
  
  // Recurrence (JSON for flexibility)
  recurrence  Json?       // { type: 'daily'|'weekly'|'monthly', interval: 1, endDate: '...' }
  
  // Relations
  projectId   String?
  project     Project?    @relation(fields: [projectId], references: [id], onDelete: Cascade)
  
  createdById String
  createdBy   User        @relation("EventCreator", fields: [createdById], references: [id])
  
  // Participants (for approval workflow)
  vendorId    String?
  vendor      VendorProfile? @relation("VendorEvents", fields: [vendorId], references: [id])
  clientId    String?
  client      ClientProfile? @relation("ClientEvents", fields: [clientId], references: [id])
  
  // Meeting Details
  meetingLink String?     // Google Meet, Teams, Zoom
  location    String?
  
  // Proposed Date (when someone proposes alternative)
  proposedStartDate DateTime?
  proposedEndDate   DateTime?
  proposedBy        String?   // userId who proposed
  proposalComment   String?   @db.Text
  
  // Metadata
  color       String?     // Hex color for display
  
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  
  attendees   EventAttendee[]
  reminders   EventReminder[]
}

model EventAttendee {
  id        String         @id @default(uuid())
  eventId   String
  event     CalendarEvent  @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  userId    String
  user      User           @relation(fields: [userId], references: [id])
  
  status    AttendeeStatus @default(NO_RESPONSE)
  comment   String?        // Decline reason, notes
  
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
  
  @@unique([eventId, userId])
}

model EventReminder {
  id        String        @id @default(uuid())
  eventId   String
  event     CalendarEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  userId    String
  user      User          @relation(fields: [userId], references: [id])
  
  minutesBefore Int        // 15, 30, 60, 1440 (1 day), etc.
  sent      Boolean       @default(false)
  
  createdAt DateTime      @default(now())
  
  @@unique([eventId, userId, minutesBefore])
}

model RequirementTemplate {
  id          String        @id @default(uuid())
  vendorId    String
  vendor      VendorProfile @relation("VendorTemplates", fields: [vendorId], references: [id])
  name        String
  description String?
  structure   Json
  isDefault   Boolean       @default(false)
  status      String        @default("DRAFT") // DRAFT, PUBLISHED
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
}

model Project {
  id       String        @id @default(uuid())
  clientId String
  client   ClientProfile @relation(fields: [clientId], references: [id])

  // Optional: If the project is a direct request to a specific vendor
  vendorId String?
  vendor   VendorProfile? @relation("VendorProjects", fields: [vendorId], references: [id])

  title       String
  description String
  budget      Float
  status      ProjectStatus @default(OPEN)

  // Stores the filled data from the RequirementTemplate
  templateData Json?

  // Reason for rejection if status is DECLINED
  rejectionReason String?

  // Tracking & Management
  startDate DateTime?
  endDate   DateTime?
  repoUrl   String?
  repoName  String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  milestones Milestone[]
  proposals  Proposal[]
  files      ProjectFile[]
  folders    ProjectFolder[]

  conversation Conversation?
  contract     Contract?

  // New Relations
  incidents Incident[]
  reviews   Review[]
  githubSync GitHubSync?
  events    CalendarEvent[]
}

model ProjectFolder {
  id        String          @id @default(uuid())
  name      String
  projectId String
  project   Project         @relation(fields: [projectId], references: [id])
  parent    ProjectFolder?  @relation("FolderHierarchy", fields: [parentId], references: [id])
  parentId  String?
  children  ProjectFolder[] @relation("FolderHierarchy")
  files     ProjectFile[]
  createdAt DateTime        @default(now())
}

model ProjectFile {
  id         String         @id @default(uuid())
  name       String
  url        String
  size       Int
  mimeType   String
  projectId  String
  project    Project        @relation(fields: [projectId], references: [id])
  folderId   String?
  folder     ProjectFolder? @relation(fields: [folderId], references: [id])
  uploaderId String
  createdAt  DateTime       @default(now())
}

model Milestone {
  id          String          @id @default(uuid())
  projectId   String
  project     Project         @relation(fields: [projectId], references: [id])
  title       String
  description String?
  amount      Float
  status      MilestoneStatus @default(PENDING)
  dueDate     DateTime?
  order       Int             @default(0)
  isPaid      Boolean         @default(false)

  // For milestones without payment
  completionNote String?
  completedAt    DateTime?

  // Payment request relation
  paymentRequest PaymentRequest?

  // Deliverables folders (protected files) - multiple allowed
  deliverableFolders DeliverableFolder[]
}

model Proposal {
  id          String        @id @default(uuid())
  projectId   String
  project     Project       @relation(fields: [projectId], references: [id])
  vendorId    String
  vendor      VendorProfile @relation(fields: [vendorId], references: [id])
  price       Float
  coverLetter String
  status      String        @default("PENDING") // PENDING, ACCEPTED, REJECTED
  createdAt   DateTime      @default(now())
}

model Review {
  id        String        @id @default(uuid())
  projectId String?
  project   Project?      @relation(fields: [projectId], references: [id])
  vendorId  String
  vendor    VendorProfile @relation(fields: [vendorId], references: [id])
  rating    Int
  comment   String?
  createdAt DateTime      @default(now())
}

model Conversation {
  id        String  @id @default(uuid())
  projectId String  @unique // One conversation per project for now
  project   Project @relation(fields: [projectId], references: [id])

  participants User[] // Many-to-many implicit relation or manual if needed. For now simple implicit is fine or we rely on project client/vendor.

  messages Message[]

  archivedBy String[] @default([])
  deletedBy  String[] @default([])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Message {
  id             String       @id @default(uuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id])

  senderId String
  sender   User   @relation(fields: [senderId], references: [id])

  content   String
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())
}

enum ContractStatus {
  DRAFT
  PENDING_SIGNATURE
  SIGNED
  CANCELLED
}

model Contract {
  id        String  @id @default(uuid())
  projectId String  @unique
  project   Project @relation(fields: [projectId], references: [id])

  content String @db.Text
  status  String @default("DRAFT") // DRAFT, PROPOSED, NEGOTIATING, SIGNED

  clientSigned   Boolean   @default(false)
  clientSignedAt DateTime?
  vendorSigned   Boolean   @default(false)
  vendorSignedAt DateTime?

  activeVersionId String?           @unique
  versions        ContractVersion[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ContractVersion {
  id         String   @id @default(uuid())
  contractId String
  contract   Contract @relation(fields: [contractId], references: [id], onDelete: Cascade)

  versionNumber Int
  content       String  @db.Text
  changeMessage String? @db.Text

  createdBy String
  status    String @default("PROPOSED") // DRAFT, PROPOSED, ACCEPTED, REJECTED

  clientSignedAt DateTime?
  vendorSignedAt DateTime?
  createdAt      DateTime  @default(now())
}

enum NotificationType {
  INFO
  SUCCESS
  WARNING
  ERROR
}

enum IncidentStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum IncidentPriority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

model Incident {
  id        String  @id @default(uuid())
  projectId String
  project   Project @relation(fields: [projectId], references: [id])

  reporterId String
  reporter   User   @relation("Reporter", fields: [reporterId], references: [id])

  title       String
  description String
  status      IncidentStatus   @default(OPEN)
  priority    IncidentPriority @default(MEDIUM)

  resolution String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Notification {
  id        String           @id @default(uuid())
  userId    String
  user      User             @relation(fields: [userId], references: [id])
  type      NotificationType @default(INFO)
  title     String
  message   String
  link      String?
  isRead    Boolean          @default(false)
  createdAt DateTime         @default(now())
}

// SavedVendor: Tracks which clients have saved/favorited which vendors
model SavedVendor {
  id        String   @id @default(uuid())
  clientId  String
  vendorId  String
  createdAt DateTime @default(now())

  client ClientProfile @relation(fields: [clientId], references: [id], onDelete: Cascade)
  vendor VendorProfile @relation(fields: [vendorId], references: [id], onDelete: Cascade)

  @@unique([clientId, vendorId])
}

// ========================================
// FINANCIAL MANAGEMENT SYSTEM
// ========================================

enum PaymentRequestStatus {
  PENDING
  APPROVED
  REJECTED
  COMPLETED
}

model PaymentRequest {
  id          String    @id @default(uuid())
  milestoneId String    @unique
  milestone   Milestone @relation(fields: [milestoneId], references: [id])

  vendorNote String?
  amount     Float
  status     PaymentRequestStatus @default(PENDING)

  requestedAt     DateTime  @default(now())
  reviewedAt      DateTime?
  rejectionReason String?

  // Link to transaction when approved
  transactionId String?      @unique
  transaction   Transaction? @relation(fields: [transactionId], references: [id])
}

model ClientAccount {
  id       String        @id @default(uuid())
  clientId String        @unique
  client   ClientProfile @relation(fields: [clientId], references: [id])

  balance  Float  @default(0)
  currency String @default("USD")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  transactionsFrom Transaction[] @relation("FromTransactions")
}

model VendorAccount {
  id       String        @id @default(uuid())
  vendorId String        @unique
  vendor   VendorProfile @relation(fields: [vendorId], references: [id])

  balance  Float  @default(0)
  currency String @default("USD")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  transactionsTo Transaction[] @relation("ToTransactions")
}

enum TransactionType {
  DEPOSIT
  WITHDRAWAL
  PAYMENT
  REFUND
  FEE
}

enum TransactionStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

model Transaction {
  id String @id @default(uuid())

  // Amount and type
  amount      Float
  type        TransactionType
  status      TransactionStatus @default(PENDING)
  description String?

  // Related accounts
  fromAccountId String?
  fromAccount   ClientAccount? @relation(fields: [fromAccountId], references: [id], name: "FromTransactions")

  toAccountId String?
  toAccount   VendorAccount? @relation(fields: [toAccountId], references: [id], name: "ToTransactions")

  //Related payment request (if applicable)
  paymentRequest PaymentRequest?

  // Related project/milestone
  projectId   String?
  milestoneId String?

  // Metadata
  metadata Json?

  createdAt   DateTime  @default(now())
  completedAt DateTime?
}

enum PaymentMethodType {
  BANK_ACCOUNT
  CREDIT_CARD
  PAYPAL
  APPLE_PAY
  GOOGLE_PAY
}

model PaymentMethod {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id])

  type      PaymentMethodType
  isDefault Boolean           @default(false)

  // Encrypted/Tokenized data
  last4    String? // Last 4 digits for display
  brand    String? // Visa, Mastercard, etc.
  metadata Json? // Store encrypted tokens, account info

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Phase 1: Notification Management
model NotificationPreference {
  id     String @id @default(uuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id])

  // Channels
  emailEnabled Boolean @default(true)
  inAppEnabled Boolean @default(true)
  smsEnabled   Boolean @default(false)

  // Categories (JSON for granular control per event type)
  projectNotifications Json @default("{\"email\": true, \"inApp\": true}")
  messageNotifications Json @default("{\"email\": true, \"inApp\": true}")
  paymentNotifications Json @default("{\"email\": true, \"inApp\": true}")
  systemNotifications  Json @default("{\"email\": true, \"inApp\": false}")

  // Digest preferences
  dailyDigest  Boolean @default(false)
  weeklyDigest Boolean @default(true)

  // Quiet hours (format: "HH:mm")
  quietHoursStart String? // e.g., "22:00"
  quietHoursEnd   String? // e.g., "08:00"

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Phase 1: Security - Session Management
model Session {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id])

  token     String @unique
  ipAddress String
  userAgent String

  createdAt    DateTime @default(now())
  expiresAt    DateTime
  lastActiveAt DateTime @default(now())

  @@index([userId])
  @@index([token])
}

// Phase 1: Security - Audit Trail
model AuditLog {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id])

  action     String // LOGIN, UPDATE_PROFILE, CHANGE_PASSWORD, etc.
  resource   String? // Resource type: Project, User, Payment, etc.
  resourceId String? // ID of affected resource
  metadata   Json? // Additional context (e.g., old/new values)
  ipAddress  String
  userAgent  String?

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([action])
  @@index([createdAt])
}

// ============== DELIVERABLES SYSTEM ==============

enum DeliverableFolderStatus {
  PENDING // Carpeta creada, vacía
  IN_PROGRESS // Vendor subiendo archivos
  READY_FOR_REVIEW // Vendor solicitó pago
  UNLOCKED // Pago aprobado, acceso completo
}

model DeliverableFolder {
  id          String    @id @default(uuid())
  milestoneId String
  milestone   Milestone @relation(fields: [milestoneId], references: [id], onDelete: Cascade)

  name   String // Nombre personalizado de la carpeta
  status DeliverableFolderStatus @default(PENDING)

  // Metadata
  totalFiles Int    @default(0)
  totalSize  BigInt @default(0) // bytes

  // Access control
  unlockedAt DateTime?
  unlockedBy String? // User ID who approved payment

  files      DeliverableFile[]
  subfolders DeliverableSubfolder[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([milestoneId])
  @@index([status])
}

model DeliverableFile {
  id       String            @id @default(uuid())
  folderId String
  folder   DeliverableFolder @relation(fields: [folderId], references: [id], onDelete: Cascade)

  subfolderId String? // Optional: which subfolder this file belongs to
  subfolder   DeliverableSubfolder? @relation(fields: [subfolderId], references: [id], onDelete: SetNull)

  // File info
  filename     String // Cleaned filename (UUID-based)
  originalName String // Original upload name
  fileSize     BigInt
  mimeType     String
  storagePath  String // Relative path: projectId/milestoneId/fileId.ext

  // Preview
  thumbnailPath    String? // For images: projectId/milestoneId/thumb_fileId.jpg
  previewAvailable Boolean @default(false)

  // Versioning (Phase 1: basic)
  version  Int     @default(1)
  isLatest Boolean @default(true)

  // Metadata
  uploadedBy String // User ID
  uploadedAt DateTime @default(now())

  @@index([folderId])
  @@index([subfolderId])
  @@index([uploadedBy])
  @@index([isLatest])
}

// Subfolders dentro de carpetas protegidas (para organización interna)
model DeliverableSubfolder {
  id       String  @id @default(uuid())
  name     String
  parentId String? // Null = raíz, otro subfolder = anidada
  folderId String // Pertenece a qué DeliverableFolder

  folder   DeliverableFolder      @relation(fields: [folderId], references: [id], onDelete: Cascade)
  parent   DeliverableSubfolder?  @relation("SubfolderTree", fields: [parentId], references: [id], onDelete: Cascade)
  children DeliverableSubfolder[] @relation("SubfolderTree")
  files    DeliverableFile[]

  createdBy String
  createdAt DateTime @default(now())

  @@index([folderId])
  @@index([parentId])
}
